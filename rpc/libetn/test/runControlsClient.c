// NOTE: Modified from source generated by rpcgen.

#include <sys/time.h>
#include <ethos/generic/assert.h>
#include <unistd.h>

#include "unitTest.h"
#include "controlTypes.h"
#include "xdrTreeFns.h"

enum {
	IterationCount = 100000,
	ProcessCount = 20
};

// Benchmark using ProcessCount processes, since ONC RPC is synchronous,
// benchmarking with one process is essentially a measure of network
// latency. We use ProcessCount to pipeline things, better stressing the
// RPC encoding/decoding itself.
#define BM(name, type, size, rpc) \
{ \
	pid_t pid = ~0; \
	for (i = 0; i < ProcessCount - 1 && pid != 0; i++) { \
		pid = fork(); \
	} \
        clnt = clnt_create (host, CERTIFICATEPROG, CERTIFICATEVERS, "udp"); \
        if (clnt == NULL) { \
                clnt_pcreateerror (host); \
                exit (1); \
        } \
	gettimeofday (&now, NULL); \
	for (i = 0; i < IterationCount / ProcessCount; i++) { \
		type *result = rpc(&rpc##_arg, clnt); \
		if (NULL == result) { \
			printf ("RPC failed\n"); \
			exit (EXIT_FAILURE); \
		} \
	} \
	if (pid == 0) exit (EXIT_SUCCESS); \
	for (i = 0; i < ProcessCount - 1 && pid != 0; i++) { \
		int stat; \
		wait (&stat); \
	} \
	gettimeofday (&later, NULL); \
        clnt_destroy (clnt); \
	report (name, now, later, size); \
}

void report (char *name, struct timeval start, struct timeval end, size_t size)
{
        printf ("%s: Ran %d iterations in %f seconds, total %lld bytes\n",
                name,
                IterationCount,
               (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1000000.0,
                IterationCount * (uint64_t) size);
}

int
main (int argc, char *argv[])
{
	ASSERT (31 == ((1 << TreeHeight) - 1));
	ASSERT (4096 == strlen (FarewellAddress));

	int i;
	char *host;
        CLIENT *clnt;
        void   *result_1;
        u_int   senduint32_1_arg;
        u_quad_t  senduint64_1_arg;
        float   sendfloat32_1_arg;
        double  sendfloat64_1_arg;
        char   *sendstring_1_arg;
	Uint32Array senduint32array_1_arg;
	CertificateHeader    header;
        IdentityCertificate  sendcertificate_1_arg;
	Torture sendtorture_1_arg;
	TreeNode *sendtreenode_1_arg = treeBuild (TreeHeight);
	struct timeval now, later;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];

	BM ("32-bit Integer", uint32_t, sizeof (uint32_t), senduint32_1);
	BM ("64-bit Integer", uint64_t, sizeof (uint64_t), senduint64_1);
	BM ("32-bit Float", float, sizeof (float), sendfloat32_1);
	BM ("64-bit Float", double, sizeof (double), sendfloat64_1);

	sendstring_1_arg = FarewellAddress;
	BM ("4096-byte String", char *, strlen (FarewellAddress), sendstring_1);

	BM ("32-bit Integer Array", u_int *, sizeof (Uint32Array), senduint32array_1);

	sendcertificate_1_arg.header = header;
	sendcertificate_1_arg.subject = HelloWorld;
	BM ("Certificate",
	     IdentityCertificate,
	     sizeof (IdentityCertificate) + sizeof (CertificateHeader) + strlen (HelloWorld),
	     sendcertificate_1);

	sendtorture_1_arg.p = malloc (sizeof (uint32_t));
	sendtorture_1_arg.t = HelloWorld;
	BM ("Torture", Torture, sizeof (Torture) + strlen (HelloWorld), sendtorture_1);

	BM ("32-node Tree", TreeNode, sizeof(TreeNode) * ((1 << TreeHeight) - 1), sendtreenode_1);

	exit (0);
}
